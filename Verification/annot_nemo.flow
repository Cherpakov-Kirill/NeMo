import lingo/pegcode/driver;
import NeMo/nemo;
import Verification/formula;

export {
    AnnotProgram(
            nemoProg : Program, 
            beforeCond : Formula, 
            afterCond : Formula, 
            invariants : Tree<Loop, Formula>,
            formulas : Tree<string, FormDefenition>,
            functions : Tree<string, FuncDefenition>
    );

    str2annotProgram(program: string) -> Maybe<AnnotProgram>;
    annotProg2s(annotProg : AnnotProgram) -> string;
}

makeFormDefenition(fl: [flow]) -> Pair<string, FormDefenition>{
    defenition = FormDefenition(fl[1], fl[2]);
    Pair(fl[0], defenition);;
}

makeFuncDefenition(fl: [flow]) -> Pair<string, FuncDefenition>{
    defenition = FuncDefenition(fl[1], fl[2]);
    println("funcName = " + fl[0]);
    Pair(fl[0], defenition);
}

makeEquivalence(fl: [flow]) -> AndF{
    AndF(ImplicationF(fl[0], fl[1]),ImplicationF(fl[1], fl[0]));
}

makeBinaryPredicate(fl: [flow]) -> PredicateEF{
    PredicateEF(fl[0], [fl[1], fl[2]]);
}

makeVarPredicate(fl: [flow]) -> PredicateEF{
    PredicateEF(fl[0], []);
}

makeTerms(fl: [flow]) -> [TermF]{
    concat([fl[0]], fl[1]);
} 

str2annotProgram(program: string) -> Maybe<AnnotProgram> {
    invariants /*: Tree<Loop, Formula>*/ = ref makeTree();
    treeSequence = setTree(defaultPegActions.t, "makeSequence", makeSequence);
    treeChoice = setTree(treeSequence, "makeChoise", makeChoise);
    treeLoop = setTree(treeChoice,"makeAnnotLoop", \fl ->{
        loop = Loop(fl[0]);
        invariants := setTree(^invariants, loop, fl[1]);
        loop;
    });
    treeIf = setTree(treeLoop, "makeIfElse", makeIfElse);
    treeWhile = setTree(treeIf, "makeAnnotWhile", \fl ->{
        leftExpr = fl[0];
        cond = fl[1];
        rightExpr = fl[2]; 
        body = fl[3];
        loop = Loop(Sequence([Test(cond, leftExpr, rightExpr), body]));
        invariants := setTree(^invariants, loop, fl[4]);
        Sequence([
            loop,
            Test(reverseCondition(cond), leftExpr, rightExpr)
        ]);
    });
    treeBool = setTree(treeWhile, "makeBool", makeBool);
    treeMinusInt = setTree(treeBool, "makeMinusInt", makeMinusInt);
    binaryPredicateTree = setTree(treeMinusInt, "makeBinaryPredicate", makeBinaryPredicate);
    varPredicateTree = setTree(binaryPredicateTree, "makeVarPredicate", makeVarPredicate);
    termsTree = setTree(varPredicateTree, "makeTerms", makeTerms);
    equivalenceTree = setTree(termsTree, "makeEquivalence", makeEquivalence);
    formTree = setTree(equivalenceTree, "makeFormDefenition", makeFormDefenition);
    funcTree = setTree(formTree, "makeFuncDefenition", makeFuncDefenition);
    fullThree = setTree(funcTree, "makeAnnotProgram", \fl -> {
        AnnotProgram(Program(fl[0],fl[3]), fl[4], fl[5], ^invariants, pairs2tree(fl[1]), pairs2tree(fl[2]));
    });
    pegActions = SemanticActions(fullThree);
    grammar = "#include Verification/annot_nemo.lingo";
    ret = parsic3(compilePegGrammar(grammar), program, pegActions, AnnotProgram(Program([],Print(IntExpr(0))),FalseEF(), FalseEF(), makeTree(), makeTree(), makeTree()));
    //println(ret.first);
    if(ret.third==""){
        Some(ret.first);
    }else{
        None();
    }
}

annotProg2s(annotProg : AnnotProgram) -> string {
	strGlue(map(annotProg.nemoProg.declarations, variable2str), "\n") + "\n" +
	foldTree(annotProg.formulas, "", \name, def, acc -> 
		acc + "formula "+ name + "(" + strGlue(def.arguments, ", ") + ") " + formula2s(def.formBody) + "\n"
	) + "\n" +
	foldTree(annotProg.functions, "", \name, def, acc -> 
		acc + "function "+ name + "(" + strGlue(def.arguments, ", ") + ") " + term2s(def.funcBody) + "\n"
	) + "\n" +
	"{ " + formula2s(annotProg.beforeCond) + " }\n" +
	annotProgBody2str(annotProg.nemoProg.body, annotProg.invariants) + "\n"
	"{ " + formula2s(annotProg.afterCond) + " }\n"
}

annotProgBody2str(body : Body, invariants : Tree<Loop, Formula>) -> string {
    switch (body) {
        Assign(var, value): {
            var + " := " + expression2str(value);
        }
        Test(operation, leftExpr, rightExpr): {
            addEndOfLine("(" + expression2str(leftExpr) + " " + operation + " " + expression2str(rightExpr) + ")?");
        }
        Sequence(bodies): {
            addEndOfLine("(" + rtrim2(fold(bodies, "", \acc, body_i -> acc + annotProgBody2str(body_i, invariants) + "; "),"; ") + ")");
        }             
        Choice(bodies): {
            addEndOfLine("(" + rtrim2(fold(bodies, "", \acc, body_i -> acc + annotProgBody2str(body_i, invariants) + " U ")," U ") + ")");
        }                
        Loop(progBody): {
            addEndOfLine(
                switch (lookupTree(invariants, body)) {
				    Some(inv): "*" + " { " + formula2s(inv) + " } (" + annotProgBody2str(progBody, invariants)  + ")";
				    None(): "*("  + annotProgBody2str(progBody, invariants) + ")";
                }
            );
        }                       
        Print(expr): {
            addEndOfLine("print(" + expression2str(expr) + ")");
        }
    }
}
