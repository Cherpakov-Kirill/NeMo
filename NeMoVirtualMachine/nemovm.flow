import runtime;
import lingo/pegcode/driver;

export{
    VMProgram(declarations : [VMVariable], instructions : [VMInstruction]);

    VMInstruction(label : int, body : VMBody);

    VMBody ::= VMAssign, VMTest, VMPrint;
    VMAssign(var: string, value: VMExpression, goto : [int]);                 ///var := expr
    VMTest(operation: string, l: VMExpression, r: VMExpression, iflabel : [int], elselabel : [int]);  ///(body)?
    VMPrint(expr: VMExpression, goto : [int]);                                ///print(expr)

    VMVariable(name : string, type : VMType);

    VMType ::= VMInt, VMArray;
    VMInt();
    VMArray(type : VMType);

    VMExpression ::= VMMathOpExpr, VMArSetValExpr, VMArGetValExpr, VMArLenExpr, VMVarExpr, VMIntExpr;
    VMMathOpExpr(operation: string, l: VMExpression, r: VMExpression);
    VMArSetValExpr(array: VMVarExpr, index: VMExpression, value: VMExpression);
    VMArGetValExpr(array: VMVarExpr, index: VMExpression);
    VMArLenExpr(array: VMVarExpr);
    VMVarExpr(name: string);
    VMIntExpr(value: int);

    str2vmprogram(program : string) -> Maybe<VMProgram>;
    vmprogram2str(program: VMProgram) -> string;
}

makeLabelsArray(labels: [flow]) -> [int]{
    concat([labels[0]], labels[1]);
}

makeMinusInt(bodies: [flow]) -> VMIntExpr{
    val = bodies[0];
    VMIntExpr(val*(-1));
}

str2vmprogram(program : string) -> Maybe<VMProgram> {
    treeLabels = setTree(defaultPegActions.t, "makeLabelsArray", makeLabelsArray);
    fullThree = setTree(treeLabels, "makeMinusInt", makeMinusInt);
    pegActions = SemanticActions(fullThree);
    grammar = "#include NeMoVirtualMachine/nemovm.lingo";
    ret = parsic3(compilePegGrammar(grammar), program, pegActions, VMProgram([],[VMInstruction(0,VMPrint(VMIntExpr(0),[]))]));
    if(ret.third==""){
        Some(ret.first);
    }else{
        None();
    }
}

vmprogram2str(program: VMProgram) -> string{
    declarations = vmvariables2str(program.declarations);
    instructions = vminstructions2str(program.instructions);
    declarations + instructions;
}

vmvariables2str(vars : [VMVariable]) -> string {
    variableStrings = map(vars, vmvariable2str);
    concatStrings(variableStrings);
}

vmvariable2str(var : VMVariable) -> string {
    nameStr = var.name;
    typeStr = vmtype2str(var.type);
    "VAR " + nameStr + " : " + typeStr + ";\n";
}

vmtype2str(type: VMType) -> string{
    switch (type : VMType) {
        VMInt(): {
            "INT";
        }
        VMArray(t): {
            "[" + vmtype2str(t) + "]";
        }
    }
}

vminstructions2str(instructions : [VMInstruction]) -> string{
    instructionStrings = map(instructions, vminstruction2str);
    concatStrings(instructionStrings);
}

vminstruction2str(instruction : VMInstruction) -> string{
    i2s(instruction.label) + ": " + vmprogBody2str(instruction.body);
}

array2str(arr : [int]) -> string{
    "{" + rtrim2(fold(arr, "", \acc, elem_i -> acc + i2s(elem_i) + ", "), ", ") + "}";
}

vmprogBody2str(body : VMBody) -> string {
    switch (body) {
        VMAssign(var, value, goto): {
            var + " := " + vmexpression2str(value) + " goto " + array2str(goto) + "\n";
        }
        VMTest(operation, leftExpr, rightExpr, ifLabels, elseLabels): {
            "if (" + vmexpression2str(leftExpr) + " " + operation + " " + vmexpression2str(rightExpr) + ") then " + array2str(ifLabels) + " else " + array2str(elseLabels) + "\n";
        }         
        VMPrint(expr, goto): {
            "print(" + vmexpression2str(expr) + ") goto " + array2str(goto) + "\n";
        }
    }
}

vmexpression2str(expr : VMExpression) -> string {
    switch (expr) {
        VMMathOpExpr(operation, l, r): {
            "(" + vmexpression2str(l) + " " + operation + " " + vmexpression2str(r) + ")";
        }
        VMArSetValExpr(array, index, value): {
            "(set(" + vmexpression2str(array) + ", " + vmexpression2str(index) + ", " + vmexpression2str(value) + "))";
        }
        VMArGetValExpr(array, index): {
            "(get(" + vmexpression2str(array) + ", " + vmexpression2str(index) + "))";
        }
        VMArLenExpr(array): {
            "(len(" + vmexpression2str(array) + "))";
        }
        VMVarExpr(name): {
            name;
        }
        VMIntExpr(value): {
            i2s(value);
        }
    }
}
